My query is to find whether a node is in the left half subtrees or the right half subtrees of a node *root*.

Suppose a node *root* has n child and each of which has subtrees.

A node is said to be in the left half subtrees of *root*, if it one of children numbered `[1..(Math.floor(n/2))]` from left to right or is a node in one of their subtrees, else it is in the right half subtrees of *root* `[(Math.floor(n/2) + 1)..n]`.


----------


**Idea**: *Preprocessing*

Do an inorder traversal of the tree and assign key(Whole numbers) to each node. Then on query,

    QUERY(root, queryNode)
      if (queryNode.key < root.key) {
        print "queryNode is in left half of root"
      } else {
        print "queryNode is in the right half of root"
      }


----------


**Implementation:**


<!-- begin snippet: js hide: false console: true babel: false -->

<!-- language: lang-js -->

    var adjacencyLists = {
      root: 'A',
      nodes: {
        A: {
          id: 'A',
          connectedNodes: ['B', 'C']
        },
        B: {
          id: 'B',
          connectedNodes: ['D', 'E']
        },
        C: {
          id: 'C',
          connectedNodes: ['F', 'G', 'H', 'Q', 'R']
        },
        D: {
          id: 'D',
          connectedNodes: []
        },
        E: {
          id: 'E',
          connectedNodes: ['K']
        },
        F: {
          id: 'F',
          connectedNodes: ['I']
        },
        G: {
          id: 'G',
          connectedNodes: ['J', 'L', 'N', 'P']
        },
        H: {
          id: 'H',
          connectedNodes: ['M', 'O']
        },
        K: {
          id: 'K',
          connectedNodes: []
        },
        I: {
          id: 'I',
          connectedNodes: []
        },
        J: {
          id: 'J',
          connectedNodes: []
        },
        L: {
          id: 'L',
          connectedNodes: []
        },
        M: {
          id: 'M',
          connectedNodes: []
        },
        N: {
          id: 'N',
          connectedNodes: []
        },
        O: {
          id: 'O',
          connectedNodes: []
        },
        P: {
          id: 'P',
          connectedNodes: []
        },
        Q: {
          id: 'Q',
          connectedNodes: []
        },
        R: {
          id: 'R',
          connectedNodes: []
        },
      }
    }

    var count = 0;

    function inorderTraversalNumbering(cur) {
      if (adjacencyLists.nodes[cur].connectedNodes.length) {
        // recurse left half subtrees
        for (let i = 0; i < Math.ceil(adjacencyLists.nodes[cur].connectedNodes.length / 2); i++) {
          inorderTraversalNumbering(adjacencyLists.nodes[cur].connectedNodes[i]);
        }
        // recurse right half subtrees
        for (let i = Math.ceil(adjacencyLists.nodes[cur].connectedNodes.length / 2); i < adjacencyLists.nodes[cur].connectedNodes.length; i++) {
          inorderTraversalNumbering(adjacencyLists.nodes[cur].connectedNodes[i]);
        }
        count++;
        adjacencyLists.nodes[cur].key = count;
      } else {
        count++;
        adjacencyLists.nodes[cur].key = count;
      }
    }

    inorderTraversalNumbering(adjacencyLists.root);
    console.log(adjacencyLists)

<!-- end snippet -->


----------

**Expected key values of nodes**: An inorder traversal of the adjacency list should assign following key to nodes:

    D: 1,
    B: 2,
    K: 3,
    E: 4,
    A: 5,
    I: 6,
    F: 7,
    J: 8,
    L: 9,
    G: 10,
    N: 11,
    P: 12,
    C: 13,
    M: 14,
    H: 15,
    O: 16,
    Q: 17,
    R: 18

